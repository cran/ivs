% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vector.R
\name{vector-detect}
\alias{vector-detect}
\alias{iv_between}
\alias{iv_includes}
\title{Detect relationships between a vector and an iv}
\usage{
iv_between(needles, haystack, ..., missing = "equals")

iv_includes(needles, haystack, ..., missing = "equals")
}
\arguments{
\item{needles, haystack}{\verb{[vector, iv]}

For \verb{iv_*_between()}, \code{needles} should be a vector and \code{haystack} should be
an iv.

For \verb{iv_*_includes()}, \code{needles} should be an iv and \code{haystack} should be
a vector.
\itemize{
\item Each element of \code{needles} represents the value / interval to match.
\item \code{haystack} represents the values / intervals to match against.
}}

\item{...}{These dots are for future extensions and must be empty.}

\item{missing}{\verb{[logical(1) / "equals" / "error"]}

Handling of missing values in \code{needles}.
\itemize{
\item \code{"equals"} considers missing values in \code{needles} as exactly equal
to missing values in \code{haystack} when determining if there is a
matching relationship between them. Matched missing values in
\code{needles} result in a \code{TRUE} value in the result, and unmatched missing
values result in a \code{FALSE} value.
\item \code{"error"} throws an error if any values in \code{needles} are missing.
\item If a single logical value is provided, this represents the value returned
in the result for values in \code{needles} that are missing. You can force
missing values to be unmatched by setting this to \code{FALSE}, and you
can force them to be propagated by setting this to \code{NA}.
}}
}
\value{
A logical vector the same size as \code{needles}.
}
\description{
This family of functions detects different types of relationships between a
vector and an iv. It works similar to \link[base:match]{base::\%in\%}, where \code{needles[i]}
checks for a match in all of \code{haystack}.
\itemize{
\item \code{iv_between()} detects when \code{needles}, a vector, falls between the
bounds in \code{haystack}, an iv.
\item \code{iv_includes()} detects when \code{needles}, an iv, includes the values
of \code{haystack}, a vector.
}

This function returns a logical vector the same size as \code{needles} containing
\code{TRUE} if the value in \code{needles} matches any value in \code{haystack} and \code{FALSE}
otherwise.
}
\examples{
x <- as.Date(c("2019-01-05", "2019-01-10", "2019-01-07", "2019-01-20"))

y <- iv_pairs(
  as.Date(c("2019-01-01", "2019-01-03")),
  as.Date(c("2019-01-04", "2019-01-08")),
  as.Date(c("2019-01-07", "2019-01-09")),
  as.Date(c("2019-01-10", "2019-01-20")),
  as.Date(c("2019-01-15", "2019-01-20"))
)

x
y

# Detect if the i-th location in `x` is between any intervals in `y`
iv_between(x, y)

# Detect if the i-th location in `y` includes any value in `x`
iv_includes(y, x)

# ---------------------------------------------------------------------------

a <- c(1, NA)
b <- iv(c(NA, NA), c(NA, NA))

# By default, missing values in `needles` are treated as being exactly
# equal to missing values in `haystack`, so the missing value in `a` is
# considered between the missing interval in `b`.
iv_between(a, b)
iv_includes(b, a)

# If you'd like to propagate missing values, set `missing = NA`
iv_between(a, b, missing = NA)
iv_includes(b, a, missing = NA)

# If you'd like missing values to be treated as unmatched, set
# `missing = FALSE`
iv_between(a, b, missing = FALSE)
iv_includes(b, a, missing = FALSE)
}
\seealso{
\link[=relation-locate]{Locating relationships}

\link[=vector-locate]{Locating relationships between a vector and an iv}

\link[=vector-detect-pairwise]{Pairwise detect relationships between a vector and an iv}
}
