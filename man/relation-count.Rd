% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/relation.R
\name{relation-count}
\alias{relation-count}
\alias{iv_count_overlaps}
\alias{iv_count_precedes}
\alias{iv_count_follows}
\title{Count relationships between two ivs}
\usage{
iv_count_overlaps(
  needles,
  haystack,
  ...,
  type = "any",
  missing = "equals",
  no_match = 0L
)

iv_count_precedes(
  needles,
  haystack,
  ...,
  closest = FALSE,
  missing = "equals",
  no_match = 0L
)

iv_count_follows(
  needles,
  haystack,
  ...,
  closest = FALSE,
  missing = "equals",
  no_match = 0L
)
}
\arguments{
\item{needles}{\verb{[iv]}

Interval vectors used for relation matching.
\itemize{
\item Each element of \code{needles} represents the interval to search for.
\item \code{haystack} represents the intervals to search in.
}

Prior to comparison, \code{needles} and \code{haystack} are coerced to the same type.}

\item{haystack}{\verb{[iv]}

Interval vectors used for relation matching.
\itemize{
\item Each element of \code{needles} represents the interval to search for.
\item \code{haystack} represents the intervals to search in.
}

Prior to comparison, \code{needles} and \code{haystack} are coerced to the same type.}

\item{...}{These dots are for future extensions and must be empty.}

\item{type}{\verb{[character(1)]}

The type of relationship to find. One of:
\itemize{
\item \code{"any"}: Finds any overlap whatsoever between an interval in \code{needles}
and an interval in \code{haystack}.
\item \code{"within"}: Finds when an interval in \code{needles} is completely within
(or equal to) an interval in \code{haystack}.
\item \code{"contains"}: Finds when an interval in \code{needles} completely contains
(or equals) an interval in \code{haystack}.
\item \code{"equals"}: Finds when an interval in \code{needles} is exactly equal to
an interval in \code{haystack}.
\item \code{"starts"}: Finds when the start of an interval in \code{needles} matches the
start of an interval in \code{haystack}.
\item \code{"ends"}: Finds when the end of an interval in \code{needles} matches the end
of an interval in \code{haystack}.
}}

\item{missing}{\verb{[integer(1) / "equals" / "error"]}

Handling of missing intervals in \code{needles}.
\itemize{
\item \code{"equals"} considers missing intervals in \code{needles} as exactly equal
to missing intervals in \code{haystack} when determining if there is a
matching relationship between them.
\item \code{"error"} throws an error if any intervals in \code{needles} are missing.
\item If a single integer value is provided, this represents the count returned
for a missing interval in \code{needles}. Use \code{0L} to force missing intervals
to never match.
}}

\item{no_match}{\verb{[integer(1) / "error"]}

Handling of \code{needles} without a match.
\itemize{
\item \code{"error"} throws an error if any needles have zero matches.
\item If a single integer is provided, this represents the count returned for
a needle with zero matches. The default value gives unmatched needles
a count of \code{0L}.
}}

\item{closest}{\verb{[TRUE / FALSE]}

Should only the closest relationship be returned?

If \code{TRUE}, will only return the closest interval(s) in \code{haystack} that
the current value of \code{needles} either precedes or follows. Note that
multiple intervals can still be returned if there are ties, which can
be resolved using \code{multiple}.}
}
\value{
An integer vector the same size as \code{needles}.
}
\description{
This family of functions counts different types of relationships between
two ivs. It works similar to \code{\link[base:match]{base::match()}}, where \code{needles[i]} checks for
a relationship in all of \code{haystack}.
\itemize{
\item \code{iv_count_overlaps()} counts instances of a specific \code{type} of overlap
between the two ivs.
\item \code{iv_count_precedes()} counts instances when \code{needles[i]} precedes (i.e.
comes before) any interval in \code{haystack}.
\item \code{iv_count_follows()} counts instances when \code{needles[i]} follows (i.e.
comes after) any interval in \code{haystack}.
}

These functions return an integer vector the same size as \code{needles}
containing a count of the times a particular relationship between the \code{i}-th
interval of \code{needles} and any interval of \code{haystack} occurred.
}
\examples{
library(vctrs)

x <- iv_pairs(
  as.Date(c("2019-01-05", "2019-01-10")),
  as.Date(c("2019-01-07", "2019-01-15")),
  as.Date(c("2019-01-20", "2019-01-31"))
)

y <- iv_pairs(
  as.Date(c("2019-01-01", "2019-01-03")),
  as.Date(c("2019-01-04", "2019-01-08")),
  as.Date(c("2019-01-07", "2019-01-09")),
  as.Date(c("2019-01-10", "2019-01-20")),
  as.Date(c("2019-01-15", "2019-01-20"))
)

x
y

# Count the number of times `x` overlaps `y` at all
iv_count_overlaps(x, y)

# Count the number of times `y` is within an interval in `x`
iv_count_overlaps(y, x, type = "within")

# Count the number of times `x` precedes `y`
iv_count_precedes(x, y)

# ---------------------------------------------------------------------------

a <- iv(c(1, NA), c(2, NA))
b <- iv(c(NA, NA), c(NA, NA))

# Missing intervals are seen as exactly equal by default, so they are
# considered to overlap
iv_count_overlaps(a, b)

# If you'd like missing intervals to be treated as unmatched, set
# `missing = 0L`
iv_count_overlaps(a, b, missing = 0L)

# If you'd like to propagate missing intervals, set `missing = NA`
iv_count_overlaps(a, b, missing = NA)
}
\seealso{
\link[=relation-locate]{Locating relationships}
}
